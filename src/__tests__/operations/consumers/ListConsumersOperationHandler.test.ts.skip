import { ListConsumersOperationHandler } from '../../../operations/consumers/ListConsumersOperationHandler';
import { createMockJetStreamManager, sampleConsumerInfo } from '../testUtils';

describe('ListConsumersOperationHandler', () => {
  let handler: ListConsumersOperationHandler;
  let mockJSM: ReturnType<typeof createMockJetStreamManager>;

  beforeEach(() => {
    handler = new ListConsumersOperationHandler();
    mockJSM = createMockJetStreamManager();
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('operationName', () => {
    it('should have correct operation name', () => {
      expect(handler.operationName).toBe('list');
    });
  });

  describe('execute', () => {
    it('should list all consumers for a stream', async () => {
      const streamName = 'TEST-STREAM';
      const expectedConsumers = [
        { ...sampleConsumerInfo, name: 'consumer-1' },
        { ...sampleConsumerInfo, name: 'consumer-2' },
        { ...sampleConsumerInfo, name: 'consumer-3' },
      ];
      
      // Create a simpler async iterator mock
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(mockJSM.consumers.list).toHaveBeenCalledWith(streamName);
      expect(result).toEqual({
        consumers: expectedConsumers,
        count: expectedConsumers.length,
      });
    });

    it('should handle empty consumer list', async () => {
      const streamName = 'EMPTY-STREAM';
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          // Empty iterator
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(mockJSM.consumers.list).toHaveBeenCalledWith(streamName);
      expect(result).toEqual({
        consumers: [],
        count: 0,
      });
    });

    it('should handle single consumer result', async () => {
      const streamName = 'SINGLE-CONSUMER-STREAM';
      const expectedConsumers = [
        { ...sampleConsumerInfo, name: 'only-consumer' },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          yield expectedConsumers[0];
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(result).toEqual({
        consumers: expectedConsumers,
        count: 1,
      });
    });

    it('should handle large number of consumers', async () => {
      const streamName = 'MANY-CONSUMERS-STREAM';
      const expectedConsumers = Array.from({ length: 50 }, (_, i) => ({
        ...sampleConsumerInfo,
        name: `consumer-${i + 1}`,
        config: {
          ...sampleConsumerInfo.config,
          durable_name: `consumer-${i + 1}`,
        },
      }));
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(result).toEqual({
        consumers: expectedConsumers,
        count: 50,
      });
    });

    it('should list consumers with various configurations', async () => {
      const streamName = 'DIVERSE-STREAM';
      const expectedConsumers = [
        {
          ...sampleConsumerInfo,
          name: 'durable-consumer',
          config: {
            ...sampleConsumerInfo.config,
            durable_name: 'durable-consumer',
            ack_policy: 'explicit' as const,
          },
        },
        {
          ...sampleConsumerInfo,
          name: 'ephemeral-consumer',
          config: {
            ...sampleConsumerInfo.config,
            durable_name: '',
            ack_policy: 'none' as const,
          },
        },
        {
          ...sampleConsumerInfo,
          name: 'filtered-consumer',
          config: {
            ...sampleConsumerInfo.config,
            durable_name: 'filtered-consumer',
            filter_subject: 'orders.*',
          },
        },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(result.consumers).toHaveLength(3);
      expect((result.consumers as any[])[0].config.ack_policy).toBe('explicit');
      expect((result.consumers as any[])[1].config.durable_name).toBe('');
      expect((result.consumers as any[])[2].config.filter_subject).toBe('orders.*');
    });

    it('should list consumers with delivery statistics', async () => {
      const streamName = 'STATS-STREAM';
      const expectedConsumers = [
        {
          ...sampleConsumerInfo,
          name: 'active-consumer',
          delivered: {
            consumer_seq: 1000,
            stream_seq: 1000,
            last_active: new Date(),
          },
          ack_floor: {
            consumer_seq: 950,
            stream_seq: 950,
            last_active: new Date(),
          },
          num_ack_pending: 50,
          num_redelivered: 5,
          num_waiting: 2,
          num_pending: 100,
        },
        {
          ...sampleConsumerInfo,
          name: 'idle-consumer',
          delivered: {
            consumer_seq: 0,
            stream_seq: 0,
            last_active: new Date(Date.now() - 3600000), // 1 hour ago
          },
          ack_floor: {
            consumer_seq: 0,
            stream_seq: 0,
            last_active: new Date(Date.now() - 3600000),
          },
          num_ack_pending: 0,
          num_redelivered: 0,
          num_waiting: 0,
          num_pending: 0,
        },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(result.consumers).toHaveLength(2);
      expect((result.consumers as any[])[0].num_ack_pending).toBe(50);
      expect((result.consumers as any[])[1].num_ack_pending).toBe(0);
    });

    it('should handle stream names with special characters', async () => {
      const streamName = 'STREAM_WITH-SPECIAL_CHARS';
      const expectedConsumers = [
        { ...sampleConsumerInfo, name: 'test-consumer' },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          yield expectedConsumers[0];
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(mockJSM.consumers.list).toHaveBeenCalledWith(streamName);
      expect(result.consumers).toHaveLength(1);
    });

    it('should propagate stream not found errors', async () => {
      const streamName = 'NONEXISTENT-STREAM';
      
      const notFoundError = new Error('Stream not found');
      (notFoundError as any).code = '404';
      mockJSM.consumers.list.mockRejectedValue(notFoundError);

      await expect(handler.execute(mockJSM, { streamName })).rejects.toThrow('Stream not found');
      expect(mockJSM.consumers.list).toHaveBeenCalledWith(streamName);
    });

    it('should propagate permission errors', async () => {
      const streamName = 'RESTRICTED-STREAM';
      
      const permissionError = new Error('Permission denied for consumer listing');
      (permissionError as any).code = '403';
      mockJSM.consumers.list.mockRejectedValue(permissionError);

      await expect(handler.execute(mockJSM, { streamName })).rejects.toThrow('Permission denied for consumer listing');
      expect(mockJSM.consumers.list).toHaveBeenCalledWith(streamName);
    });

    it('should handle network timeout errors', async () => {
      const streamName = 'TEST-STREAM';
      
      const timeoutError = new Error('Consumer list timeout');
      (timeoutError as any).code = 'TIMEOUT';
      mockJSM.consumers.list.mockRejectedValue(timeoutError);

      await expect(handler.execute(mockJSM, { streamName })).rejects.toThrow('Consumer list timeout');
    });

    it('should handle JetStream not enabled errors', async () => {
      const streamName = 'TEST-STREAM';
      
      const jetStreamError = new Error('JetStream not enabled for account');
      (jetStreamError as any).code = '503';
      mockJSM.consumers.list.mockRejectedValue(jetStreamError);

      await expect(handler.execute(mockJSM, { streamName })).rejects.toThrow('JetStream not enabled for account');
    });

    it('should handle iterator errors during iteration', async () => {
      const streamName = 'ERROR-STREAM';
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          yield { ...sampleConsumerInfo, name: 'consumer-1' };
          throw new Error('Iterator error during consumer listing');
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      await expect(handler.execute(mockJSM, { streamName })).rejects.toThrow('Iterator error during consumer listing');
    });

    it('should preserve consumer order', async () => {
      const streamName = 'ORDERED-STREAM';
      const expectedConsumers = [
        { ...sampleConsumerInfo, name: 'alpha-consumer' },
        { ...sampleConsumerInfo, name: 'beta-consumer' },
        { ...sampleConsumerInfo, name: 'gamma-consumer' },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      const consumerNames = (result.consumers as any[]).map(c => c.name);
      expect(consumerNames).toEqual(['alpha-consumer', 'beta-consumer', 'gamma-consumer']);
    });

    it('should handle consumers with complex names', async () => {
      const streamName = 'COMPLEX-NAMES-STREAM';
      const expectedConsumers = [
        { ...sampleConsumerInfo, name: 'consumer-with_underscores' },
        { ...sampleConsumerInfo, name: 'consumer-with-dashes' },
        { ...sampleConsumerInfo, name: 'ConsumerWithCamelCase' },
        { ...sampleConsumerInfo, name: 'consumer123withNumbers456' },
      ];
      
      const mockAsyncIterator = {
        async *[Symbol.asyncIterator]() {
          for (const consumer of expectedConsumers) {
            yield consumer;
          }
        }
      };
      
      mockJSM.consumers.list.mockReturnValue(mockAsyncIterator);

      const result = await handler.execute(mockJSM, { streamName });

      expect(result.consumers).toHaveLength(4);
      const names = (result.consumers as any[]).map(c => c.name);
      expect(names).toContain('consumer-with_underscores');
      expect(names).toContain('ConsumerWithCamelCase');
    });
  });
});